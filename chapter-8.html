<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chapter 8: Not feathers…what exactly does the model predict? &#8212; How They Think</title>
  <meta property="og:title" content="Chapter 8: Not feathers…what exactly does the model predict? — How They Think">
  <meta property="og:description" content="An online book about how ChatGPT works">
  <meta property="og:image" content="https://ericsilberstein1.github.io/how-they-think-book/images/ogimage.png">
  <meta property="og:type" content="article">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <nav class="chapter-nav">
    <a href="chapter-7.html">&#8592; Previous</a>
    <a href="index.html">Contents</a>
    <a href="chapter-9.html">Next &#8594;</a>
  </nav>
  <article>
    <div class="chapter-heading">
      <p class="chapter-number">8</p>
      <hr class="chapter-rule">
      <h1>Not feathers…what exactly does the model predict?</h1>
    </div>
    <p>OpenAI released GPT-3 in a private beta in mid-2020. I don’t remember exactly when I got access. I was the head of data science at Klaviyo at the time and we were already working with OpenAI. At some point the model appeared in our account. You could input a prompt and it would generate text. This was around the same time I published my first novel, <em>The Insecure Mind of Sergei Kraev,</em> so I tried putting in the first few sentences of my prologue:</p>
    <div class="inset">
      <p>April 14, 2220</p>
      <p>One hundred years after 4-17</p>
      <p>Singapore Island</p>
      <p>Children,</p>
      <p>This is my ninety-fourth annual message.</p>
    </div>
    <p>Here are three first paragraphs generated by GPT-3 and the paragraph from my actual prologue. Can you guess which is the real one?</p>
    <figure id="fig-8-1">
      <input type="checkbox" id="lb-70" class="lightbox-toggle">
      <label for="lb-70"><img src="images/RC064.png" alt="" loading="lazy"></label>
      <label for="lb-70" class="lightbox-overlay"><img src="images/RC064.png" alt=""></label>
      <figcaption>Figure 8.1. Three of these paragraphs were generated by GPT-3 in 2021. One is from the actual prologue to my novel.</figcaption>
    </figure>
    <p>Toward the end of 2021 Klaviyo released a feature to help people write email subject lines. The user would say a little bit about what they wanted, the model would generate four ideas, and the user could pick one or ask for more to be generated. Under the hood we inserted the user’s input and other information about the user into a prompt template, sent this to GPT-3, and parsed the subject line ideas out of the response that came back. This way of building systems has become widespread but it was novel only a few years ago.</p>
    <p>Despite being an early user of GPT-3, and despite knowing that GPT-3 and its predecessors were fundamentally next token prediction models, and despite having experience with other types of models, I could not have answered these three questions:</p>
    <ul>
      <li>During training, what exactly are the X and Y? (See the example in <a href="chapter-5.html" class="xref">chapter 5</a> for what I mean by X and Y.)</li>
      <li>During training, how is loss calculated? (I explained how we calculated loss for our turkey model in <a href="chapter-3.html" class="xref">chapter 3</a>.)</li>
      <li>How exactly do you use the model to generate text? What’s the input? What’s the output?</li>
    </ul>
    <p>Let’s answer these questions. I find it’s helpful to think about the inputs and outputs before looking at what’s inside the model. With a firm grasp on what we’re starting with and what we’re trying to get to, it will be easier, later, to trace the operations inside the model. Until we crack it open in <a href="chapter-11.html" class="xref">chapter 11</a>, we’ll treat our GPT model as a black box.</p>
    <hr class="section-break">
    <p>Pretend we are again in the strange land from <a href="chapter-2.html" class="xref">chapter 2</a> where the only words in their language are: a, bed, he, house, is, man, red, store, the, to, and went. We’re going to begin our training on some text scraped off the web of this strange land: <strong>“he went to the store.”</strong></p>
    <p>We start our training by inputting the <em>beginning of sequence</em> token into the model. The model outputs its prediction for the next token which comes in the form of a probability distribution over all of the tokens in the vocabulary.</p>
    <figure id="fig-8-2">
      <input type="checkbox" id="lb-71" class="lightbox-toggle">
      <label for="lb-71"><img src="images/RC065.png" alt="" loading="lazy"></label>
      <label for="lb-71" class="lightbox-overlay"><img src="images/RC065.png" alt=""></label>
      <figcaption>Figure 8.2. Input the <em>beginning of sequence</em> token and the model makes predictions for the next token.</figcaption>
    </figure>
    <p>The model really wants to start the sentence with “bed!” But we haven’t done any training yet, the weights inside the model are random, so the output is random. We don’t need to worry. We also aren’t going to do anything with “bed” at this point. We stick with our training sentence: “he went to the store.” So now we input the first two tokens in the sequence:</p>
    <figure id="fig-8-3" style="max-width:90%">
      <input type="checkbox" id="lb-72" class="lightbox-toggle">
      <label for="lb-72"><img src="images/RC066.png" alt="" loading="lazy"></label>
      <label for="lb-72" class="lightbox-overlay"><img src="images/RC066.png" alt=""></label>
      <figcaption>Figure 8.3. Input the first two tokens and the model predicts the probability of each possible next token.</figcaption>
    </figure>
    <p>Again, we haven’t done any training yet, so we don’t need to worry about the model predicting that “he” is likely to follow “he.”</p>
    <p>Keep going until we’ve done a prediction on the full sequence up to but not including the last token. Let’s put all of these predictions in a single table:</p>
    <figure id="tbl-8-1">
      <input type="checkbox" id="lb-73" class="lightbox-toggle">
      <label for="lb-73"><img src="images/RC067.png" alt="" loading="lazy"></label>
      <label for="lb-73" class="lightbox-overlay"><img src="images/RC067.png" alt=""></label>
      <figcaption>Table 8.1. The next token predictions for “&lt;bos&gt;,” “&lt;bos&gt; he”, all the way up to “&lt;bos&gt; he went to the.”</figcaption>
    </figure>
    <p>At this point you might see where this is going, and your mind may be objecting. Wait, if you start a sentence with “he,” there are so many valid next words, are we really going to teach the model that “went” should come next? Even “he went to” has many valid next words besides “the!” Good point. But it’s not a problem because we’ll have lots of training data and some might push the weights toward predicting “the” next, others toward “bed,” others toward “a,” but none toward “he” or “went.” And no matter what, we’ll be careful to never adjust the weights too much based only on a single batch of training data. More about batches to come.</p>
    <p>Looking at the table, we can articulate what we want: update the weights such that, unlike now, column 1 will give top probability to “he,” column 2 will give top probability to “went,” column 3 will give top probability to “to,” column 4 to “the,” and column 5 to “store.” To get backpropagation to figure out how to nudge each weight in the right direction to get this overall result, we need a single number that represents how we’re doing and can be maximized or minimized. Let’s try multiplying the probabilities of the tokens we want the model to predict:</p>
    <figure id="tbl-8-2">
      <input type="checkbox" id="lb-74" class="lightbox-toggle">
      <label for="lb-74"><img src="images/RC068.png" alt="" loading="lazy"></label>
      <label for="lb-74" class="lightbox-overlay"><img src="images/RC068.png" alt=""></label>
      <figcaption>Table 8.2: Purple indicates tokens we want the model to predict. At the moment it’s not doing a very good job.</figcaption>
    </figure>
    <p>So that’s:</p>
    <div class="inset">
      <p>0.05% × 2.48% × 5.72% × 4.72% × 40.54% = 0.000001357%</p>
    </div>
    <p>Suppose we tweak the weights and now the 0.05% becomes 0.09% and also suppose all but one of the other probabilities also move up:</p>
    <div class="inset">
      <p>0.09% × 2.49% × 5.74% × 4.75% × 40.51% = 0.000002475%</p>
    </div>
    <p>This seems right. The model made a better prediction and the overall probability went up, so multiplying the probabilities of the correct tokens seems to be a useful score. This multiplication of probabilities results in a single number that says how good a job our model is doing. You may remember from the turkey example that by convention we want a loss function that we can minimize. The less loss the better is the way to think about it. To match that convention, we can multiply our product of probabilities score by -1 and now it’s a loss function.</p>
    <p>This is more or less the entire training concept. We have data, we have a loss function, backprop can work its magic, and if our model architecture is good enough, the model will train and the loss will come down.</p>
    <p>My son, who’s been reading as I’ve been writing, got to <a href="chapter-18.html" class="xref">chapter 18</a> and realized he was confused about the loss function. It <em>is</em> confusing. Until you get used to it, it feels strange to ignore most of the probabilities and consider only those for the correct next token according to the training data. To help solidify the idea, we’ll do one more example. Let’s say the training text is <strong>“&lt;bos&gt; the house is red”</strong> and let’s say I’ve predicted all the next tokens using two versions of the model:</p>
    <figure id="tbl-8-3">
      <input type="checkbox" id="lb-75" class="lightbox-toggle">
      <label for="lb-75"><img src="images/RC368.png" alt="" loading="lazy"></label>
      <label for="lb-75" class="lightbox-overlay"><img src="images/RC368.png" alt=""></label>
      <figcaption> Table 8.3: Which model has lower loss?</figcaption>
    </figure>
    <p>Which model has lower loss? In other words, which model is doing better at least as judged by the training text “&lt;bos&gt; the house is red”? Please think about this and make sure you can answer before you move on. I’ll put the answer at the end of the chapter.</p>
    <hr class="section-break">
    <p>If you look at <a href="#fig-8-2" class="xref" data-preview="images/RC065.png">figure 8.2</a> with “&lt;bos&gt;” being fed into the model, and then <a href="#fig-8-3" class="xref" data-preview="images/RC066.png">figure 8.3</a> with “&lt;bos&gt; he” being fed in, and then you were to go find the loop in code that’s being used to train the model, you’ll be puzzled, because you’ll never see just “&lt;bos&gt;” or just “&lt;bos&gt; he” being input to the model. What you’ll see will look more like this:</p>
    <figure id="fig-8-4">
      <input type="checkbox" id="lb-76" class="lightbox-toggle">
      <label for="lb-76"><img src="images/RC069.png" alt="" loading="lazy"></label>
      <label for="lb-76" class="lightbox-overlay"><img src="images/RC069.png" alt=""></label>
      <figcaption>Figure 8.4. During training the full sequence is fed into the model at once, not token by token.</figcaption>
    </figure>
    <p>The whole sequence goes in one time and the probability distributions for all of the next tokens come out. You might be thinking—who cares, that’s just a more efficient way to do it. Or you might be thinking—won’t the model cheat? Instead of learning to predict, it will just learn to assign a probability near 100% to whatever token is next since it knows the next token from its input. Both thoughts are valid.</p>
    <p>On efficiency, yes, the technique of sending in the full sequence at once really just is a way to be more efficient. We’ll get the same results either way. Remember from the discussion of matrices and GPUs in <a href="chapter-5.html" class="xref">chapter 5</a>, however, that it’s essential to give the problem to the GPU in big chunks. Otherwise it can’t use its massive parallelism to compute efficiently.</p>
    <p>In the introduction I mentioned that I trained a 20-layer model before I started writing this book. During that training, for which I used NVIDIA H100 chips, I fed over 60,000 tokens at time to each GPU. The GPU could make predictions on all 60,000 tokens, calculate loss, <em>and</em> adjust the model weights in less than half a second.</p>
    <p>And about cheating, yes, that confused me at first. Models love to cheat. With enough weights, and enough training cycles, that signal from the gradient will make them do crazy things. If they can cheat their way to lowering the loss, meaning doing so in a way that you as the designer didn’t intend or realize was possible, they’ll do it.</p>
    <p>But not to fear. The transformer architecture won’t let the model cheat. In <a href="chapter-14.html" class="xref">chapter 14</a> we’ll discuss <strong>masked</strong> <strong>multi-head self-attention</strong>. You’ll see how <em>masking</em> guarantees that when, for example, the model is predicting the token after “went” in “He went to the store,” it can’t peek at “to.”</p>
    <p>In <a href="#fig-8-4" class="xref" data-preview="images/RC069.png">figure 8.4</a> I showed a whole sequence of tokens going into the model at once. Even that is a little bit of a simplification. During actual training we’ll be feeding in a <strong>batch</strong> of sequences at a time. This is again so we can give the GPU as chunky a problem to work on. If we’re doing a good job, our GPUs will consume all of their memory and all of their computing power for the entire training process.</p>
    <p>Let me show you a batch of size 3 (call that B) with a sequence length of 5 (call that T for number of tokens). The first sequence will be our friend from above “&lt;bos&gt; He went to the.”</p>
    <figure id="fig-8-5" style="max-width:70%">
      <input type="checkbox" id="lb-77" class="lightbox-toggle">
      <label for="lb-77"><img src="images/RC301.png" alt="" loading="lazy"></label>
      <label for="lb-77" class="lightbox-overlay"><img src="images/RC301.png" alt=""></label>
      <figcaption>Figure 8.5. A batch of three sequences.</figcaption>
    </figure>
    <p>Now let’s see what we get when we feed the batch into the model. Our vocab size is still 12 and we’ll call that V.</p>
    <figure id="fig-8-6">
      <input type="checkbox" id="lb-78" class="lightbox-toggle">
      <label for="lb-78"><img src="images/RC070.png" alt="" loading="lazy"></label>
      <label for="lb-78" class="lightbox-overlay"><img src="images/RC070.png" alt=""></label>
      <figcaption>Figure 8.6. A small but realistic view of the input and output.</figcaption>
    </figure>
    <p>It may take time to wrap your mind around this tiny but realistic example. I replaced the words with token IDs. For example, 0 is “&lt;bos&gt;” and 3 is “He.” You’ll see that the input is a matrix just like the turkey data going into the turkey model in <a href="chapter-5.html#fig-5-3" class="xref" data-preview="images/RC031.png">figure 5.3</a>. The matrix here has size B×T meaning B rows and T columns. Think of this, again, as a batch of 3 sequences each with 5 tokens.</p>
    <p>The output is trickier. Its size is B×T×V. You can see why we need that extra dimension: we have three sequences in the batch, for each we’re making five next token predictions (one for each token), and each prediction consists of twelve numbers (one for each token in the vocab). I may also have confused you by switching the rows and columns in this diagram as compared to the diagrams above. In the diagrams above (e.g. <a href="#fig-8-2" class="xref" data-preview="images/RC065.png">figure 8.2</a>), I was aiming for legibility, so I used 12 rows to show the probability distribution over the 12 tokens. In this <a href="#fig-8-6" class="xref" data-preview="images/RC070.png">figure 8.6</a> I switched to match the convention of how it’s usually done in code and used ellipses to make the numbers fit.</p>
    <p>Up until now every matrix we’ve seen had two dimensions, and by the math definition, a matrix always has exactly two dimensions: rows and columns. So we probably shouldn’t call this B×T×V thing a matrix. In AI and machine learning and in the widely used PyTorch library it’s called a <strong>tensor</strong>, so we’ll go with that, as in: the output of the model is a tensor of size B by T by V.</p>
    <p>When I first heard that AI used tensors, back when Google came out with something called TensorFlow in 2015, I was intimidated. Two of my roommates in college majored in physics and I remembered that they dealt with tensors, for example in quantum physics. Quantum physics may or may not be scary, but tensors themselves are no scarier than matrices. They are just an organized way to group a bunch of numbers. In fact there are other software tools that call them <em>multidimensional arrays</em>, a term much less intimidating to someone with a computer science background.</p>
    <p>No matter what you call it, a tensor is an organized way to keep track of a bunch of numbers representing data, interim calculations, or output. How many numbers? For our B×T×V output it’s 3 × 5 × 12 = 180 numbers. Say I want to pull out of the tensor a specific number, say the probability that the first predicted token in the first sequence is “went.” You can see at the top right of <a href="#fig-8-6" class="xref" data-preview="images/RC070.png">figure 8.6</a> that this is 0.02. In code I could get that with output[0,0,11]. Why 0? Because in code things are normally zero-indexed meaning you start counting at zero. (This makes sense because these numbers will be stored in memory somewhere and the first one will be at that location + 0 × bytes per number, the second one at that location + 1 × bytes per number, etc.) So output[0,0,11] means the first item in the “B” dimension, the first item in the “T” dimension, and the 12th item in the “V” dimension.</p>
    <p>I’ll show you a few examples so you can see how powerful, intuitive, and concise this notation is for accessing parts of a tensor. As or more important as making sense to humans is that you can specify operations you want the GPU to do without picking out pieces of data one at a time. This allows the GPU to do what it does best—work in parallel.</p>
    <p>The first example is the same one I gave in the text above. We pull a single element out of the tensor resulting in a tensor with no dimensions (called a <strong>scalar)</strong>:</p>
    <figure id="fig-8-7" style="max-width:50%">
      <input type="checkbox" id="lb-79" class="lightbox-toggle">
      <label for="lb-79"><img src="images/RC071.png" alt="" loading="lazy"></label>
      <label for="lb-79" class="lightbox-overlay"><img src="images/RC071.png" alt=""></label>
      <figcaption>Figure 8.7. Example of indexing into a tensor.</figcaption>
    </figure>
    <p>In this second example, we take a <strong>slice</strong> with all elements from the first sequence in the batch and the prediction for the first token from that sequence. This results in a tensor with a single dimension representing the probability distribution of the prediction for the first token over the vocabulary:</p>
    <figure id="fig-8-8">
      <input type="checkbox" id="lb-80" class="lightbox-toggle">
      <label for="lb-80"><img src="images/RC072.png" alt="" loading="lazy"></label>
      <label for="lb-80" class="lightbox-overlay"><img src="images/RC072.png" alt=""></label>
      <figcaption>Figure 8.8. Example of indexing into a tensor.</figcaption>
    </figure>
    <p>In this third example, we take a slice with all elements from the first sequence in the batch. This results in a tensor with two dimensions of size T×V (5 × 12), the same one shown in <a href="#fig-8-6" class="xref" data-preview="images/RC070.png">figure 8.6</a>:</p>
    <figure id="fig-8-9">
      <input type="checkbox" id="lb-81" class="lightbox-toggle">
      <label for="lb-81"><img src="images/RC073.png" alt="" loading="lazy"></label>
      <label for="lb-81" class="lightbox-overlay"><img src="images/RC073.png" alt=""></label>
      <figcaption>Figure 8.9. Example of indexing into a tensor.</figcaption>
    </figure>
    <hr class="section-break">
    <p>For training, you’ve now seen what we input to the model, what the model outputs, and how we use the output to calculate loss. To actually calculate loss we need to know the correct next tokens, as indicated in purple in <a href="#tbl-8-2" class="xref" data-preview="images/RC068.png">table 8.2</a>. We even need the final next tokens for each sequence which are not in our input batch. In practice we form a y_actual tensor, just like the turkey example. This is very similar to our input but shifted over. It excludes the <em>beginning of sequence</em> token, which we’re not trying to predict, and includes the final token “store,” which we do want to predict.</p>
    <figure id="fig-8-10" style="max-width:90%">
      <input type="checkbox" id="lb-82" class="lightbox-toggle">
      <label for="lb-82"><img src="images/RC074.png" alt="" loading="lazy"></label>
      <label for="lb-82" class="lightbox-overlay"><img src="images/RC074.png" alt=""></label>
      <figcaption>Figure 8.10. X goes into the model, y_actual goes into the loss calculation.</figcaption>
    </figure>
    <p>Taking the first row in x and y_actual as an example, our goal is that 0 predicts 3, 3 predicts 11, 11 predicts 10, etc. The final token in x in the first row, 9 “the,” should predict 8 “store.” (Keep in mind that when I say 9 should predict 8, what I really mean is that the full sequence 0, 3, 11, 10, 9 should predict 8.)</p>
    <p>Now putting it all together:</p>
    <figure id="fig-8-11">
      <input type="checkbox" id="lb-83" class="lightbox-toggle">
      <label for="lb-83"><img src="images/RC075.png" alt="" loading="lazy"></label>
      <label for="lb-83" class="lightbox-overlay"><img src="images/RC075.png" alt=""></label>
      <figcaption>Figure 8.11. The big picture of how loss is computed from x and y_actual.</figcaption>
    </figure>
    <p>Purple indicates the dimensions of each tensor. When looking at this diagram, remember the point of boiling everything down to a single loss number is so we can backpropagate and adjust the weights. In <a href="chapter-11.html" class="xref">chapter 11</a> we’ll start to get into what goes on inside the model and exactly what those weights are.</p>
    <p>I’ve been using a tiny example for the diagrams. When I trained my 20-layer model ahead of time, which has a vocabulary size of 65,536 tokens and over a half a million weights, I used batches of 32 sequences each with 2048 tokens (B=32, T=2048). Here’s the diagrams again with these dimensions multiplied out so you can appreciate how many numbers we’re dealing with:</p>
    <figure id="fig-8-12">
      <input type="checkbox" id="lb-84" class="lightbox-toggle">
      <label for="lb-84"><img src="images/RC076.png" alt="" loading="lazy"></label>
      <label for="lb-84" class="lightbox-overlay"><img src="images/RC076.png" alt=""></label>
      <figcaption>Figure 8.12. The total numbers in the tensors to compute loss for a single batch.</figcaption>
    </figure>
    <p>In a single round of the training loop in the turkey example, we adjusted two weights using a batch of three pieces of data, each containing height, length, and actual number of feathers. Here, in a single round of the training loop, we’re adjusting over half a million weights based on backpropagating through a calculation that starts with 65,536 numbers and produces an output of over 4 billion numbers. In <a href="chapter-21.html" class="xref">chapter 21</a>, when we start training our 32-layer model, we’ll be adjusting over 2 billion weights. The fact that this actually works speaks to the incredible power of backpropagation and calculus and innovations in model architecture that we’ll be covering in upcoming chapters, and the fact it can be done in a fraction of a second speaks to the power of GPUs.</p>
    <hr class="section-break">
    <figure id="fig-8-13">
      <input type="checkbox" id="lb-85" class="lightbox-toggle">
      <label for="lb-85"><img src="images/RC077.png" alt="" loading="lazy"></label>
      <label for="lb-85" class="lightbox-overlay"><img src="images/RC077.png" alt=""></label>
      <figcaption>Figure 8.13. Where our batches come from during training.</figcaption>
    </figure>
    <p>To build an intuition for scale, let’s do a back of the envelope calculation. A page of English text might be 1500 characters. An average word in English is 4 to 5 characters, many of those words will correspond to single tokens, many of those tokens will include a leading space, so let’s assume 5 characters per token. So a page is 1500 ÷ 5 = 300 tokens. We need 65,000+ tokens worth of text, so that’s over 200 pages. Think a short novel, a whole bunch of wikipedia articles, a lot of business documents, or many discussion threads.</p>
    <p>To make this even more visceral and concrete, I’m going to read the first document in my dataset of text, the second document, the third, and so on until I accumulate enough tokens to fill my batch. The table below shows these documents. For each I show the beginning of the document and the total number of characters. I encode each into tokens and show the first three tokens and the total number of tokens.</p>
    <figure id="tbl-8-4">
      <input type="checkbox" id="lb-86" class="lightbox-toggle">
      <label for="lb-86"><img src="images/RC078.png" alt="" loading="lazy"></label>
      <label for="lb-86" class="lightbox-overlay"><img src="images/RC078.png" alt=""></label>
      <figcaption>Table 8.4. Enough documents to fill one training batch.</figcaption>
    </figure>
    <p>The first thing that may jump out is how random these documents appear. Search for the snippets of text and you’ll find most of them on the internet because that’s where the text came from in the first place. I’m still in awe that it’s possible to achieve something so useful from so much random text. Even decades ago people talked about data being valuable, but I’m not sure they meant this type of data. On the other hand, our human minds are good at consuming lots of information from lots of sources at varying levels of quality and forming a reasonably coherent mental model of things, so maybe it’s not so crazy.</p>
    <p>You may also notice that the first token is always ID 65527. If you look back at <a href="chapter-7.html#tbl-7-10" class="xref" data-preview="images/RC063.png">table 7.10</a> you’ll see that 65527 is the ID of our special <em>beginning of sequence</em> token.</p>
    <p>Overall it takes around 320,000 characters to get to our desired number of tokens. This is around 320 kilobytes, about a third of a megabyte. The character-to-token ratio for this data works out to 4.86 (320,093 ÷ 65,901) so my guess of 5 above wasn’t far off.</p>
    <p>And here’s how the tokens look organized into tensors in the GPU memory all set for the forward calculation of loss and the backward calculation to update the weights.</p>
    <figure id="fig-8-14">
      <input type="checkbox" id="lb-87" class="lightbox-toggle">
      <label for="lb-87"><img src="images/RC079.png" alt="" loading="lazy"></label>
      <label for="lb-87" class="lightbox-overlay"><img src="images/RC079.png" alt=""></label>
      <figcaption>Figure 8.14. Example of x and y_target at the actual size I used to train my 20-layer model.</figcaption>
    </figure>
    <hr class="section-break">
    <p>Before we move on, I want to get into one other simplification that I made. If you’ve had enough math for now skip ahead to the next chapter. If, though, something about the loss function is bothering you, read on.</p>
    <p>When I showed the loss function under <a href="#tbl-8-2" class="xref" data-preview="images/RC068.png">table 8.2</a>, I described how we pulled out the five relevant probabilities, multiplied them, and made the whole thing negative:</p>
    <div class="inset">
      <p>loss = -1 × 0.05% × 2.48% × 5.72% × 4.72% × 40.54% = -0.000001357% </p>
    </div>
    <p>That’s only five probabilities and the resulting number is very small. What’s going to happen when we multiply 2048 probabilities, or 65,536? In some sort of ideal world with infinite precision we would end up with an incredibly small but still meaningful number and backprop would work just fine. In the real world of computers we don’t get all that much precision (see <a href="chapter-30.html" class="xref">chapter 30</a>) and the calculation will be meaningless.</p>
    <p>You may remember from high school that multiplying numbers is similar to adding their logs. Here’s an example:</p>
    <div class="inset">
      <p>2 × 3 = 6</p>
      <p>e<sup>(ln(2) + ln(3))</sup> = e<sup>(</sup><sup>0.693 + 1.099)</sup> = e<sup>1.792</sup> = 6</p>
    </div>
    <p>We can apply the same idea to our loss calculation. Here are the five probabilities and their logs:</p>
    <figure id="tbl-8-5">
      <input type="checkbox" id="lb-88" class="lightbox-toggle">
      <label for="lb-88"><img src="images/RC302.png" alt="" loading="lazy"></label>
      <label for="lb-88" class="lightbox-overlay"><img src="images/RC302.png" alt=""></label>
      <figcaption>Table 8.5. The logs of the probabilities.</figcaption>
    </figure>
    <p>You can already see that adding a number like -7.60 to a bunch of other numbers of similar magnitudes is going to cause less trouble than multiplying 0.05 by other small numbers. Let’s multiply out the probabilities and add up the logs and raise them to the power of e to show that we’ll get the same result as above.</p>
    <figure id="tbl-8-6" style="max-width:70%">
      <input type="checkbox" id="lb-89" class="lightbox-toggle">
      <label for="lb-89"><img src="images/RC303.png" alt="" loading="lazy"></label>
      <label for="lb-89" class="lightbox-overlay"><img src="images/RC303.png" alt=""></label>
      <figcaption>Table 8.6. Multiplying probabilities is like adding their logs.</figcaption>
    </figure>
    <p>Now your next thought might be—hmm, why do I even need to convert back to a probability? Everything will work out much better if we just convert each probability predicted by the model for the correct token into a log and never go back. Even better, let’s convert and multiply by -1 so we don’t have to remember to do it later. This will give us per-token numbers. We can then add the numbers together or average them to get the overall loss. This is called <strong>negative log loss</strong> or NLL.</p>
    <figure id="tbl-8-7">
      <input type="checkbox" id="lb-90" class="lightbox-toggle">
      <label for="lb-90"><img src="images/RC306.png" alt="" loading="lazy"></label>
      <label for="lb-90" class="lightbox-overlay"><img src="images/RC306.png" alt=""></label>
      <figcaption>Table 8.7. Calculating negative log loss.</figcaption>
    </figure>
    <p>Now we’re back to a single, clear loss number. Since the logs of probabilities between 0% and 100% are negative, and we’re multiplying again by -1, the signs can get confusing. As a sanity check, let’s imagine we tweak the weights such that the 0.05% becomes 0.09% (a good thing) and confirm that our loss comes down.</p>
    <figure id="tbl-8-8">
      <input type="checkbox" id="lb-91" class="lightbox-toggle">
      <label for="lb-91"><img src="images/RC307.png" alt="" loading="lazy"></label>
      <label for="lb-91" class="lightbox-overlay"><img src="images/RC307.png" alt=""></label>
      <figcaption>Table 8.8. When the predicted probability of the correct token goes up the negative log loss comes down.</figcaption>
    </figure>
    <p>Loss drops from 3.62 to 3.51 moving in the direction we expect. Good!</p>
    <p>Finally, let me also tell you the name of the loss function we’re using in case you want to learn more about it: <strong>cross-entropy loss</strong>.</p>
    <hr class="section-break">
    <p>While you have the whole idea of negative log loss in your head, I want to also bring up <strong>unnormalized logits</strong> because if you hear about them, you may wonder if they’re the same as per-token negative log loss. They are not.</p>
    <p>We haven’t looked inside the model yet. When we do, you’ll see that getting to a proper probability distribution over the vocabulary for each next token prediction is the very last step. As a reminder of what I mean by a proper probability distribution, I’m talking about each of the columns in <a href="#tbl-8-1" class="xref" data-preview="images/RC067.png">table 8.1</a> at the start of this chapter that add up to 100%. In that table there are twelve numbers. In our 20-layer and 32-layer models there will be 65,536 numbers due to the size of the vocabulary.</p>
    <p>In fact, it’s such a last step that you can almost think of it as a part of the loss calculation rather than a part of the model itself. The numbers in the final output of the model just prior to conversion to a probability distribution are called unnormalized logits. They will come in a tensor of size B×T×V just as I’ve shown in <a href="#fig-8-11" class="xref" data-preview="images/RC075.png">figure 8.11</a>, but the V numbers for a particular next token prediction will <em>not</em> sum to one, will not all be in the range from 0 to 1, and may include negative numbers. Here’s an example for a single token prediction using our size 12 vocabulary:</p>
    <figure id="tbl-8-9" style="max-width:60%">
      <input type="checkbox" id="lb-92" class="lightbox-toggle">
      <label for="lb-92"><img src="images/RC308.png" alt="" loading="lazy"></label>
      <label for="lb-92" class="lightbox-overlay"><img src="images/RC308.png" alt=""></label>
      <figcaption>Table 8.9. Example of unnormalized logits.</figcaption>
    </figure>
    <p>Converting to a probability distribution is done via <strong>softmax</strong>. I’ll show the calculation in a spreadsheet:</p>
    <figure id="tbl-8-10" style="max-width:70%">
      <input type="checkbox" id="lb-93" class="lightbox-toggle">
      <label for="lb-93"><img src="images/RC309.png" alt="" loading="lazy"></label>
      <label for="lb-93" class="lightbox-overlay"><img src="images/RC309.png" alt=""></label>
      <figcaption>Table 8.10. Using softmax to normalize unnormalized logits into a probability distribution.</figcaption>
    </figure>
    <p>We take the exponential (e<sup>x</sup>) of each unnormalized logit, sum, then divide each into that sum. In practice, the low level code used in model training is optimized for turning unnormalized logits into negative log loss and we don’t need to directly work with raw probabilities. By optimized I mean that the calculation is both fast and numerically stable, i.e. it won’t blow up due to numbers that are too large.</p>
    <p>Notice that the greater the unnormalized logit, the higher the probability of that token. So for some uses of the model beyond training, say pulling out the most likely next token, we can skip converting to probability and read this directly from the unnormalized logits. And this is a good segue to the next chapter on how we use the model to generate text.</p>
    <p>(Answer to question posed for <a href="#tbl-8-3" class="xref" data-preview="images/RC368.png">table 8.3</a>: model A is better. Compare the probabilities for the correct next tokens.)</p>
  </article>
  <nav class="chapter-nav">
    <a href="chapter-7.html">&#8592; Previous</a>
    <a href="index.html">Contents</a>
    <a href="chapter-9.html">Next &#8594;</a>
  </nav>
  <footer class="site-footer"><em>How They Think</em> &mdash; February 12, 2026 draft &mdash; &copy; Eric Silberstein</footer>
  <div id="preview-tooltip" class="preview-tooltip" hidden>
    <img id="preview-tooltip-img" src="" alt="">
  </div>
  <script>
  (function() {
    var tip = document.getElementById('preview-tooltip');
    var img = document.getElementById('preview-tooltip-img');
    var links = document.querySelectorAll('a.xref[data-preview]');
    var hideTimer;
    function show(e) {
      clearTimeout(hideTimer);
      var src = e.currentTarget.getAttribute('data-preview');
      if (img.getAttribute('src') !== src) img.setAttribute('src', src);
      tip.removeAttribute('hidden');
      position(e);
    }
    function position(e) {
      var rect = e.currentTarget.getBoundingClientRect();
      var tw = Math.min(480, window.innerWidth - 32);
      var left = rect.left + rect.width / 2 - tw / 2;
      if (left < 8) left = 8;
      if (left + tw > window.innerWidth - 8) left = window.innerWidth - 8 - tw;
      tip.style.width = tw + 'px';
      tip.style.left = left + 'px';
      var above = rect.top - 8;
      var below = window.innerHeight - rect.bottom - 8;
      if (above > below) {
        tip.style.bottom = (window.innerHeight - rect.top + 8) + 'px';
        tip.style.top = 'auto';
      } else {
        tip.style.top = (rect.bottom + 8) + 'px';
        tip.style.bottom = 'auto';
      }
    }
    function hide() {
      hideTimer = setTimeout(function() { tip.setAttribute('hidden', ''); }, 120);
    }
    links.forEach(function(a) {
      a.addEventListener('mouseenter', show);
      a.addEventListener('mouseleave', hide);
    });
    tip.addEventListener('mouseenter', function() { clearTimeout(hideTimer); });
    tip.addEventListener('mouseleave', hide);
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        var open = document.querySelector('.lightbox-toggle:checked');
        if (open) open.checked = false;
      }
    });
  })();
  </script>
</body>
</html>
